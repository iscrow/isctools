#!/usr/bin/env bash

CONNECT_TIMEOUT=2
PROCESSES=256
SCRIPT="$(basename "$0")"

function help() {
	cat <<-EOF

		$SCRIPT scans a set of subnets/IPs
	
		Usage example:
		  $SCRIPT 192.168.0.10
		  $SCRIPT 192.168.0.0/24
			$SCRIPT 192.168.1.10 192.168.2.10 192.168.3.0/28

	EOF
	exit 1
}

function cidr_validate {
	CIDR=$1
	[[ "$CIDR" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))(/(3[0-2]|[1-2]?[0-9]))?$ ]] || return 1
	echo $CIDR
}

function check_ip {
	local IP="$1"
	while read LINE; do
		echo $LINE
		break
	done < <(timeout 1 curl --connect-timeout $CONNECT_TIMEOUT -v $IP 2>&1 | grep -qP 'Server: eHTTP' && echo $IP)
}

function cidr_to_ips {
	local SUBNET="$1"
	sipcalc "$SUBNET" -s32 | awk '/Network/{print $NF}' | tr '\n' ' '
}

[ -z $(command -v sipcalc) ] && echo "$SCRIPT requires sipcalc" | colorize red . && exit 1

export -f check_ip
export CONNECT_TIMEOUT

[ -z "$*" ] && help

for SUBNET in $*; do
	if [ -z $(cidr_validate $SUBNET) ]; then
		echo
		echo "$SUBNET is not a valid IP or CIDR notation subnet. Exiting..." | colorize red .
		help
	else
		IPS+="$(cidr_to_ips $SUBNET)"
	fi
done

SWITCHES=()
COUNT=0
while read SWITCH; do
	((COUNT++))
	printf '\r%s' "FOUND: $COUNT" | colorize green '[0-9]+' >&2
	SWITCHES+=($SWITCH)
done < <(xargs -d ' ' -L1 -P$PROCESSES bash -c 'check_ip "$@"' {} <<< $IPS)
printf '\r' >&2

[ $COUNT -gt 0 ] && printf '%s\n' "${SWITCHES[@]}" | sort -V && echo "FOUND: $COUNT" | colorize green '[0-9]+' >&2
